// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: confidence/flags/resolver/v1/internal_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { Timestamp } from '../../../../google/protobuf/timestamp';
import { Sdk } from './types';

export const protobufPackage = 'confidence.flags.resolver.v1';

/**
 * The service that allows to report flag assigned and other client-side flag
 * operations, useful when the resolve engine runs on the customer's premises
 */
export interface WriteFlagLogsRequest {
  flagAssigned: FlagAssigned[];
  telemetryData?: TelemetryData | undefined;
  clientResolveInfo: ClientResolveInfo[];
  flagResolveInfo: FlagResolveInfo[];
}

export interface WriteFlagLogsResponse {}

/** Collection of telemetry metrics */
export interface TelemetryData {
  /** Information about the SDK/provider */
  sdk?: Sdk | undefined;
}

export interface ClientInfo {
  client: string;
  clientCredential: string;
  /** Information about the SDK used to interact with the API. */
  sdk?: Sdk | undefined;
}

export interface FlagAssigned {
  resolveId: string;
  clientInfo?: ClientInfo | undefined;
  flags: FlagAssigned_AppliedFlag[];
}

export interface FlagAssigned_AppliedFlag {
  flag: string;
  targetingKey: string;
  targetingKeySelector: string;
  assignmentInfo?: FlagAssigned_AssignmentInfo | undefined;
  defaultAssignment?: FlagAssigned_DefaultAssignment | undefined;
  assignmentId: string;
  rule: string;
  fallthroughAssignments: FallthroughAssignment[];
  applyTime?: Date | undefined;
}

export interface FlagAssigned_AssignmentInfo {
  segment: string;
  variant: string;
}

export interface FlagAssigned_DefaultAssignment {
  reason: FlagAssigned_DefaultAssignment_DefaultAssignmentReason;
}

export enum FlagAssigned_DefaultAssignment_DefaultAssignmentReason {
  DEFAULT_ASSIGNMENT_REASON_UNSPECIFIED = 0,
  NO_SEGMENT_MATCH = 1,
  /** @deprecated */
  NO_TREATMENT_MATCH = 2,
  FLAG_ARCHIVED = 3,
  UNRECOGNIZED = -1,
}

export function flagAssigned_DefaultAssignment_DefaultAssignmentReasonFromJSON(
  object: any,
): FlagAssigned_DefaultAssignment_DefaultAssignmentReason {
  switch (object) {
    case 0:
    case 'DEFAULT_ASSIGNMENT_REASON_UNSPECIFIED':
      return FlagAssigned_DefaultAssignment_DefaultAssignmentReason.DEFAULT_ASSIGNMENT_REASON_UNSPECIFIED;
    case 1:
    case 'NO_SEGMENT_MATCH':
      return FlagAssigned_DefaultAssignment_DefaultAssignmentReason.NO_SEGMENT_MATCH;
    case 2:
    case 'NO_TREATMENT_MATCH':
      return FlagAssigned_DefaultAssignment_DefaultAssignmentReason.NO_TREATMENT_MATCH;
    case 3:
    case 'FLAG_ARCHIVED':
      return FlagAssigned_DefaultAssignment_DefaultAssignmentReason.FLAG_ARCHIVED;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return FlagAssigned_DefaultAssignment_DefaultAssignmentReason.UNRECOGNIZED;
  }
}

export function flagAssigned_DefaultAssignment_DefaultAssignmentReasonToJSON(
  object: FlagAssigned_DefaultAssignment_DefaultAssignmentReason,
): string {
  switch (object) {
    case FlagAssigned_DefaultAssignment_DefaultAssignmentReason.DEFAULT_ASSIGNMENT_REASON_UNSPECIFIED:
      return 'DEFAULT_ASSIGNMENT_REASON_UNSPECIFIED';
    case FlagAssigned_DefaultAssignment_DefaultAssignmentReason.NO_SEGMENT_MATCH:
      return 'NO_SEGMENT_MATCH';
    case FlagAssigned_DefaultAssignment_DefaultAssignmentReason.NO_TREATMENT_MATCH:
      return 'NO_TREATMENT_MATCH';
    case FlagAssigned_DefaultAssignment_DefaultAssignmentReason.FLAG_ARCHIVED:
      return 'FLAG_ARCHIVED';
    case FlagAssigned_DefaultAssignment_DefaultAssignmentReason.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface FallthroughAssignment {
  rule: string;
  assignmentId: string;
  targetingKey: string;
  targetingKeySelector: string;
}

export interface ClientResolveInfo {
  /** Resource reference to a client. */
  client: string;
  /** Resource reference to a credential. */
  clientCredential: string;
  /** The different evaluation context schema of the client that have been seen recently. */
  schema: ClientResolveInfo_EvaluationContextSchemaInstance[];
}

/** An instance of a schema that was seen */
export interface ClientResolveInfo_EvaluationContextSchemaInstance {
  /** Schema of each field in the evaluation context. */
  schema: { [key: string]: number };
}

export interface ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
  key: string;
  value: number;
}

export interface FlagResolveInfo {
  /** The flag the info is about */
  flag: string;
  /** Information about how variants were resolved. */
  variantResolveInfo: FlagResolveInfo_VariantResolveInfo[];
}

/** Information about how a variant was resolved. */
export interface FlagResolveInfo_VariantResolveInfo {
  /** If there was a variant assigned, otherwise not set */
  variant: string;
  /** Number of times the variant was resolved in this period */
  count: number;
}

export interface WriteOperationsRequest {
  storeVariantOp: VariantData[];
}

export interface WriteOperationsResult {}

export interface VariantReadOp {
  unit: string;
  materialization: string;
  rule: string;
}

export interface InclusionReadOp {
  unit: string;
  materialization: string;
}

export interface ReadOp {
  variantReadOp?: VariantReadOp | undefined;
  inclusionReadOp?: InclusionReadOp | undefined;
}

export interface ReadOperationsRequest {
  ops: ReadOp[];
}

export interface VariantData {
  unit: string;
  materialization: string;
  rule: string;
  variant: string;
}

export interface InclusionData {
  unit: string;
  materialization: string;
  isIncluded: boolean;
}

export interface ReadResult {
  variantResult?: VariantData | undefined;
  inclusionResult?: InclusionData | undefined;
}

export interface ReadOperationsResult {
  results: ReadResult[];
}

function createBaseWriteFlagLogsRequest(): WriteFlagLogsRequest {
  return { flagAssigned: [], telemetryData: undefined, clientResolveInfo: [], flagResolveInfo: [] };
}

export const WriteFlagLogsRequest: MessageFns<WriteFlagLogsRequest> = {
  encode(message: WriteFlagLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.flagAssigned) {
      FlagAssigned.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.telemetryData !== undefined) {
      TelemetryData.encode(message.telemetryData, writer.uint32(18).fork()).join();
    }
    for (const v of message.clientResolveInfo) {
      ClientResolveInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.flagResolveInfo) {
      FlagResolveInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFlagLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFlagLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flagAssigned.push(FlagAssigned.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.telemetryData = TelemetryData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientResolveInfo.push(ClientResolveInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.flagResolveInfo.push(FlagResolveInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFlagLogsRequest {
    return {
      flagAssigned: globalThis.Array.isArray(object?.flagAssigned)
        ? object.flagAssigned.map((e: any) => FlagAssigned.fromJSON(e))
        : globalThis.Array.isArray(object?.flag_assigned)
        ? object.flag_assigned.map((e: any) => FlagAssigned.fromJSON(e))
        : [],
      telemetryData: isSet(object.telemetryData)
        ? TelemetryData.fromJSON(object.telemetryData)
        : isSet(object.telemetry_data)
        ? TelemetryData.fromJSON(object.telemetry_data)
        : undefined,
      clientResolveInfo: globalThis.Array.isArray(object?.clientResolveInfo)
        ? object.clientResolveInfo.map((e: any) => ClientResolveInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.client_resolve_info)
        ? object.client_resolve_info.map((e: any) => ClientResolveInfo.fromJSON(e))
        : [],
      flagResolveInfo: globalThis.Array.isArray(object?.flagResolveInfo)
        ? object.flagResolveInfo.map((e: any) => FlagResolveInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.flag_resolve_info)
        ? object.flag_resolve_info.map((e: any) => FlagResolveInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WriteFlagLogsRequest): unknown {
    const obj: any = {};
    if (message.flagAssigned?.length) {
      obj.flagAssigned = message.flagAssigned.map(e => FlagAssigned.toJSON(e));
    }
    if (message.telemetryData !== undefined) {
      obj.telemetryData = TelemetryData.toJSON(message.telemetryData);
    }
    if (message.clientResolveInfo?.length) {
      obj.clientResolveInfo = message.clientResolveInfo.map(e => ClientResolveInfo.toJSON(e));
    }
    if (message.flagResolveInfo?.length) {
      obj.flagResolveInfo = message.flagResolveInfo.map(e => FlagResolveInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFlagLogsRequest>, I>>(base?: I): WriteFlagLogsRequest {
    return WriteFlagLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFlagLogsRequest>, I>>(object: I): WriteFlagLogsRequest {
    const message = createBaseWriteFlagLogsRequest();
    message.flagAssigned = object.flagAssigned?.map(e => FlagAssigned.fromPartial(e)) || [];
    message.telemetryData =
      object.telemetryData !== undefined && object.telemetryData !== null
        ? TelemetryData.fromPartial(object.telemetryData)
        : undefined;
    message.clientResolveInfo = object.clientResolveInfo?.map(e => ClientResolveInfo.fromPartial(e)) || [];
    message.flagResolveInfo = object.flagResolveInfo?.map(e => FlagResolveInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWriteFlagLogsResponse(): WriteFlagLogsResponse {
  return {};
}

export const WriteFlagLogsResponse: MessageFns<WriteFlagLogsResponse> = {
  encode(_: WriteFlagLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFlagLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFlagLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WriteFlagLogsResponse {
    return {};
  },

  toJSON(_: WriteFlagLogsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFlagLogsResponse>, I>>(base?: I): WriteFlagLogsResponse {
    return WriteFlagLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFlagLogsResponse>, I>>(_: I): WriteFlagLogsResponse {
    const message = createBaseWriteFlagLogsResponse();
    return message;
  },
};

function createBaseTelemetryData(): TelemetryData {
  return { sdk: undefined };
}

export const TelemetryData: MessageFns<TelemetryData> = {
  encode(message: TelemetryData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sdk !== undefined) {
      Sdk.encode(message.sdk, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TelemetryData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTelemetryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sdk = Sdk.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TelemetryData {
    return { sdk: isSet(object.sdk) ? Sdk.fromJSON(object.sdk) : undefined };
  },

  toJSON(message: TelemetryData): unknown {
    const obj: any = {};
    if (message.sdk !== undefined) {
      obj.sdk = Sdk.toJSON(message.sdk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TelemetryData>, I>>(base?: I): TelemetryData {
    return TelemetryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TelemetryData>, I>>(object: I): TelemetryData {
    const message = createBaseTelemetryData();
    message.sdk = object.sdk !== undefined && object.sdk !== null ? Sdk.fromPartial(object.sdk) : undefined;
    return message;
  },
};

function createBaseClientInfo(): ClientInfo {
  return { client: '', clientCredential: '', sdk: undefined };
}

export const ClientInfo: MessageFns<ClientInfo> = {
  encode(message: ClientInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client !== '') {
      writer.uint32(10).string(message.client);
    }
    if (message.clientCredential !== '') {
      writer.uint32(18).string(message.clientCredential);
    }
    if (message.sdk !== undefined) {
      Sdk.encode(message.sdk, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientCredential = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sdk = Sdk.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientInfo {
    return {
      client: isSet(object.client) ? globalThis.String(object.client) : '',
      clientCredential: isSet(object.clientCredential)
        ? globalThis.String(object.clientCredential)
        : isSet(object.client_credential)
        ? globalThis.String(object.client_credential)
        : '',
      sdk: isSet(object.sdk) ? Sdk.fromJSON(object.sdk) : undefined,
    };
  },

  toJSON(message: ClientInfo): unknown {
    const obj: any = {};
    if (message.client !== '') {
      obj.client = message.client;
    }
    if (message.clientCredential !== '') {
      obj.clientCredential = message.clientCredential;
    }
    if (message.sdk !== undefined) {
      obj.sdk = Sdk.toJSON(message.sdk);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientInfo>, I>>(base?: I): ClientInfo {
    return ClientInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientInfo>, I>>(object: I): ClientInfo {
    const message = createBaseClientInfo();
    message.client = object.client ?? '';
    message.clientCredential = object.clientCredential ?? '';
    message.sdk = object.sdk !== undefined && object.sdk !== null ? Sdk.fromPartial(object.sdk) : undefined;
    return message;
  },
};

function createBaseFlagAssigned(): FlagAssigned {
  return { resolveId: '', clientInfo: undefined, flags: [] };
}

export const FlagAssigned: MessageFns<FlagAssigned> = {
  encode(message: FlagAssigned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resolveId !== '') {
      writer.uint32(82).string(message.resolveId);
    }
    if (message.clientInfo !== undefined) {
      ClientInfo.encode(message.clientInfo, writer.uint32(26).fork()).join();
    }
    for (const v of message.flags) {
      FlagAssigned_AppliedFlag.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagAssigned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagAssigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.resolveId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientInfo = ClientInfo.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.flags.push(FlagAssigned_AppliedFlag.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagAssigned {
    return {
      resolveId: isSet(object.resolveId)
        ? globalThis.String(object.resolveId)
        : isSet(object.resolve_id)
        ? globalThis.String(object.resolve_id)
        : '',
      clientInfo: isSet(object.clientInfo)
        ? ClientInfo.fromJSON(object.clientInfo)
        : isSet(object.client_info)
        ? ClientInfo.fromJSON(object.client_info)
        : undefined,
      flags: globalThis.Array.isArray(object?.flags)
        ? object.flags.map((e: any) => FlagAssigned_AppliedFlag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FlagAssigned): unknown {
    const obj: any = {};
    if (message.resolveId !== '') {
      obj.resolveId = message.resolveId;
    }
    if (message.clientInfo !== undefined) {
      obj.clientInfo = ClientInfo.toJSON(message.clientInfo);
    }
    if (message.flags?.length) {
      obj.flags = message.flags.map(e => FlagAssigned_AppliedFlag.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagAssigned>, I>>(base?: I): FlagAssigned {
    return FlagAssigned.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagAssigned>, I>>(object: I): FlagAssigned {
    const message = createBaseFlagAssigned();
    message.resolveId = object.resolveId ?? '';
    message.clientInfo =
      object.clientInfo !== undefined && object.clientInfo !== null
        ? ClientInfo.fromPartial(object.clientInfo)
        : undefined;
    message.flags = object.flags?.map(e => FlagAssigned_AppliedFlag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFlagAssigned_AppliedFlag(): FlagAssigned_AppliedFlag {
  return {
    flag: '',
    targetingKey: '',
    targetingKeySelector: '',
    assignmentInfo: undefined,
    defaultAssignment: undefined,
    assignmentId: '',
    rule: '',
    fallthroughAssignments: [],
    applyTime: undefined,
  };
}

export const FlagAssigned_AppliedFlag: MessageFns<FlagAssigned_AppliedFlag> = {
  encode(message: FlagAssigned_AppliedFlag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== '') {
      writer.uint32(10).string(message.flag);
    }
    if (message.targetingKey !== '') {
      writer.uint32(18).string(message.targetingKey);
    }
    if (message.targetingKeySelector !== '') {
      writer.uint32(26).string(message.targetingKeySelector);
    }
    if (message.assignmentInfo !== undefined) {
      FlagAssigned_AssignmentInfo.encode(message.assignmentInfo, writer.uint32(34).fork()).join();
    }
    if (message.defaultAssignment !== undefined) {
      FlagAssigned_DefaultAssignment.encode(message.defaultAssignment, writer.uint32(42).fork()).join();
    }
    if (message.assignmentId !== '') {
      writer.uint32(50).string(message.assignmentId);
    }
    if (message.rule !== '') {
      writer.uint32(58).string(message.rule);
    }
    for (const v of message.fallthroughAssignments) {
      FallthroughAssignment.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.applyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.applyTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagAssigned_AppliedFlag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagAssigned_AppliedFlag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetingKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetingKeySelector = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.assignmentInfo = FlagAssigned_AssignmentInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultAssignment = FlagAssigned_DefaultAssignment.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.assignmentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.fallthroughAssignments.push(FallthroughAssignment.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.applyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagAssigned_AppliedFlag {
    return {
      flag: isSet(object.flag) ? globalThis.String(object.flag) : '',
      targetingKey: isSet(object.targetingKey)
        ? globalThis.String(object.targetingKey)
        : isSet(object.targeting_key)
        ? globalThis.String(object.targeting_key)
        : '',
      targetingKeySelector: isSet(object.targetingKeySelector)
        ? globalThis.String(object.targetingKeySelector)
        : isSet(object.targeting_key_selector)
        ? globalThis.String(object.targeting_key_selector)
        : '',
      assignmentInfo: isSet(object.assignmentInfo)
        ? FlagAssigned_AssignmentInfo.fromJSON(object.assignmentInfo)
        : isSet(object.assignment_info)
        ? FlagAssigned_AssignmentInfo.fromJSON(object.assignment_info)
        : undefined,
      defaultAssignment: isSet(object.defaultAssignment)
        ? FlagAssigned_DefaultAssignment.fromJSON(object.defaultAssignment)
        : isSet(object.default_assignment)
        ? FlagAssigned_DefaultAssignment.fromJSON(object.default_assignment)
        : undefined,
      assignmentId: isSet(object.assignmentId)
        ? globalThis.String(object.assignmentId)
        : isSet(object.assignment_id)
        ? globalThis.String(object.assignment_id)
        : '',
      rule: isSet(object.rule) ? globalThis.String(object.rule) : '',
      fallthroughAssignments: globalThis.Array.isArray(object?.fallthroughAssignments)
        ? object.fallthroughAssignments.map((e: any) => FallthroughAssignment.fromJSON(e))
        : globalThis.Array.isArray(object?.fallthrough_assignments)
        ? object.fallthrough_assignments.map((e: any) => FallthroughAssignment.fromJSON(e))
        : [],
      applyTime: isSet(object.applyTime)
        ? fromJsonTimestamp(object.applyTime)
        : isSet(object.apply_time)
        ? fromJsonTimestamp(object.apply_time)
        : undefined,
    };
  },

  toJSON(message: FlagAssigned_AppliedFlag): unknown {
    const obj: any = {};
    if (message.flag !== '') {
      obj.flag = message.flag;
    }
    if (message.targetingKey !== '') {
      obj.targetingKey = message.targetingKey;
    }
    if (message.targetingKeySelector !== '') {
      obj.targetingKeySelector = message.targetingKeySelector;
    }
    if (message.assignmentInfo !== undefined) {
      obj.assignmentInfo = FlagAssigned_AssignmentInfo.toJSON(message.assignmentInfo);
    }
    if (message.defaultAssignment !== undefined) {
      obj.defaultAssignment = FlagAssigned_DefaultAssignment.toJSON(message.defaultAssignment);
    }
    if (message.assignmentId !== '') {
      obj.assignmentId = message.assignmentId;
    }
    if (message.rule !== '') {
      obj.rule = message.rule;
    }
    if (message.fallthroughAssignments?.length) {
      obj.fallthroughAssignments = message.fallthroughAssignments.map(e => FallthroughAssignment.toJSON(e));
    }
    if (message.applyTime !== undefined) {
      obj.applyTime = message.applyTime.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagAssigned_AppliedFlag>, I>>(base?: I): FlagAssigned_AppliedFlag {
    return FlagAssigned_AppliedFlag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagAssigned_AppliedFlag>, I>>(object: I): FlagAssigned_AppliedFlag {
    const message = createBaseFlagAssigned_AppliedFlag();
    message.flag = object.flag ?? '';
    message.targetingKey = object.targetingKey ?? '';
    message.targetingKeySelector = object.targetingKeySelector ?? '';
    message.assignmentInfo =
      object.assignmentInfo !== undefined && object.assignmentInfo !== null
        ? FlagAssigned_AssignmentInfo.fromPartial(object.assignmentInfo)
        : undefined;
    message.defaultAssignment =
      object.defaultAssignment !== undefined && object.defaultAssignment !== null
        ? FlagAssigned_DefaultAssignment.fromPartial(object.defaultAssignment)
        : undefined;
    message.assignmentId = object.assignmentId ?? '';
    message.rule = object.rule ?? '';
    message.fallthroughAssignments =
      object.fallthroughAssignments?.map(e => FallthroughAssignment.fromPartial(e)) || [];
    message.applyTime = object.applyTime ?? undefined;
    return message;
  },
};

function createBaseFlagAssigned_AssignmentInfo(): FlagAssigned_AssignmentInfo {
  return { segment: '', variant: '' };
}

export const FlagAssigned_AssignmentInfo: MessageFns<FlagAssigned_AssignmentInfo> = {
  encode(message: FlagAssigned_AssignmentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.segment !== '') {
      writer.uint32(10).string(message.segment);
    }
    if (message.variant !== '') {
      writer.uint32(18).string(message.variant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagAssigned_AssignmentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagAssigned_AssignmentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.segment = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagAssigned_AssignmentInfo {
    return {
      segment: isSet(object.segment) ? globalThis.String(object.segment) : '',
      variant: isSet(object.variant) ? globalThis.String(object.variant) : '',
    };
  },

  toJSON(message: FlagAssigned_AssignmentInfo): unknown {
    const obj: any = {};
    if (message.segment !== '') {
      obj.segment = message.segment;
    }
    if (message.variant !== '') {
      obj.variant = message.variant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagAssigned_AssignmentInfo>, I>>(base?: I): FlagAssigned_AssignmentInfo {
    return FlagAssigned_AssignmentInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagAssigned_AssignmentInfo>, I>>(object: I): FlagAssigned_AssignmentInfo {
    const message = createBaseFlagAssigned_AssignmentInfo();
    message.segment = object.segment ?? '';
    message.variant = object.variant ?? '';
    return message;
  },
};

function createBaseFlagAssigned_DefaultAssignment(): FlagAssigned_DefaultAssignment {
  return { reason: 0 };
}

export const FlagAssigned_DefaultAssignment: MessageFns<FlagAssigned_DefaultAssignment> = {
  encode(message: FlagAssigned_DefaultAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagAssigned_DefaultAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagAssigned_DefaultAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagAssigned_DefaultAssignment {
    return {
      reason: isSet(object.reason) ? flagAssigned_DefaultAssignment_DefaultAssignmentReasonFromJSON(object.reason) : 0,
    };
  },

  toJSON(message: FlagAssigned_DefaultAssignment): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = flagAssigned_DefaultAssignment_DefaultAssignmentReasonToJSON(message.reason);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagAssigned_DefaultAssignment>, I>>(base?: I): FlagAssigned_DefaultAssignment {
    return FlagAssigned_DefaultAssignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagAssigned_DefaultAssignment>, I>>(
    object: I,
  ): FlagAssigned_DefaultAssignment {
    const message = createBaseFlagAssigned_DefaultAssignment();
    message.reason = object.reason ?? 0;
    return message;
  },
};

function createBaseFallthroughAssignment(): FallthroughAssignment {
  return { rule: '', assignmentId: '', targetingKey: '', targetingKeySelector: '' };
}

export const FallthroughAssignment: MessageFns<FallthroughAssignment> = {
  encode(message: FallthroughAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rule !== '') {
      writer.uint32(10).string(message.rule);
    }
    if (message.assignmentId !== '') {
      writer.uint32(18).string(message.assignmentId);
    }
    if (message.targetingKey !== '') {
      writer.uint32(26).string(message.targetingKey);
    }
    if (message.targetingKeySelector !== '') {
      writer.uint32(34).string(message.targetingKeySelector);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FallthroughAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFallthroughAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assignmentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetingKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.targetingKeySelector = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FallthroughAssignment {
    return {
      rule: isSet(object.rule) ? globalThis.String(object.rule) : '',
      assignmentId: isSet(object.assignmentId)
        ? globalThis.String(object.assignmentId)
        : isSet(object.assignment_id)
        ? globalThis.String(object.assignment_id)
        : '',
      targetingKey: isSet(object.targetingKey)
        ? globalThis.String(object.targetingKey)
        : isSet(object.targeting_key)
        ? globalThis.String(object.targeting_key)
        : '',
      targetingKeySelector: isSet(object.targetingKeySelector)
        ? globalThis.String(object.targetingKeySelector)
        : isSet(object.targeting_key_selector)
        ? globalThis.String(object.targeting_key_selector)
        : '',
    };
  },

  toJSON(message: FallthroughAssignment): unknown {
    const obj: any = {};
    if (message.rule !== '') {
      obj.rule = message.rule;
    }
    if (message.assignmentId !== '') {
      obj.assignmentId = message.assignmentId;
    }
    if (message.targetingKey !== '') {
      obj.targetingKey = message.targetingKey;
    }
    if (message.targetingKeySelector !== '') {
      obj.targetingKeySelector = message.targetingKeySelector;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FallthroughAssignment>, I>>(base?: I): FallthroughAssignment {
    return FallthroughAssignment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FallthroughAssignment>, I>>(object: I): FallthroughAssignment {
    const message = createBaseFallthroughAssignment();
    message.rule = object.rule ?? '';
    message.assignmentId = object.assignmentId ?? '';
    message.targetingKey = object.targetingKey ?? '';
    message.targetingKeySelector = object.targetingKeySelector ?? '';
    return message;
  },
};

function createBaseClientResolveInfo(): ClientResolveInfo {
  return { client: '', clientCredential: '', schema: [] };
}

export const ClientResolveInfo: MessageFns<ClientResolveInfo> = {
  encode(message: ClientResolveInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.client !== '') {
      writer.uint32(10).string(message.client);
    }
    if (message.clientCredential !== '') {
      writer.uint32(18).string(message.clientCredential);
    }
    for (const v of message.schema) {
      ClientResolveInfo_EvaluationContextSchemaInstance.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientResolveInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientResolveInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.client = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientCredential = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema.push(ClientResolveInfo_EvaluationContextSchemaInstance.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientResolveInfo {
    return {
      client: isSet(object.client) ? globalThis.String(object.client) : '',
      clientCredential: isSet(object.clientCredential)
        ? globalThis.String(object.clientCredential)
        : isSet(object.client_credential)
        ? globalThis.String(object.client_credential)
        : '',
      schema: globalThis.Array.isArray(object?.schema)
        ? object.schema.map((e: any) => ClientResolveInfo_EvaluationContextSchemaInstance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ClientResolveInfo): unknown {
    const obj: any = {};
    if (message.client !== '') {
      obj.client = message.client;
    }
    if (message.clientCredential !== '') {
      obj.clientCredential = message.clientCredential;
    }
    if (message.schema?.length) {
      obj.schema = message.schema.map(e => ClientResolveInfo_EvaluationContextSchemaInstance.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientResolveInfo>, I>>(base?: I): ClientResolveInfo {
    return ClientResolveInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientResolveInfo>, I>>(object: I): ClientResolveInfo {
    const message = createBaseClientResolveInfo();
    message.client = object.client ?? '';
    message.clientCredential = object.clientCredential ?? '';
    message.schema = object.schema?.map(e => ClientResolveInfo_EvaluationContextSchemaInstance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseClientResolveInfo_EvaluationContextSchemaInstance(): ClientResolveInfo_EvaluationContextSchemaInstance {
  return { schema: {} };
}

export const ClientResolveInfo_EvaluationContextSchemaInstance: MessageFns<ClientResolveInfo_EvaluationContextSchemaInstance> =
  {
    encode(
      message: ClientResolveInfo_EvaluationContextSchemaInstance,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      globalThis.Object.entries(message.schema).forEach(([key, value]: [string, number]) => {
        ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ClientResolveInfo_EvaluationContextSchemaInstance {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClientResolveInfo_EvaluationContextSchemaInstance();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 = ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry.decode(
              reader,
              reader.uint32(),
            );
            if (entry1.value !== undefined) {
              message.schema[entry1.key] = entry1.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClientResolveInfo_EvaluationContextSchemaInstance {
      return {
        schema: isObject(object.schema)
          ? (globalThis.Object.entries(object.schema) as [string, any][]).reduce(
              (acc: { [key: string]: number }, [key, value]: [string, any]) => {
                acc[key] = globalThis.Number(value);
                return acc;
              },
              {},
            )
          : {},
      };
    },

    toJSON(message: ClientResolveInfo_EvaluationContextSchemaInstance): unknown {
      const obj: any = {};
      if (message.schema) {
        const entries = globalThis.Object.entries(message.schema) as [string, number][];
        if (entries.length > 0) {
          obj.schema = {};
          entries.forEach(([k, v]) => {
            obj.schema[k] = Math.round(v);
          });
        }
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ClientResolveInfo_EvaluationContextSchemaInstance>, I>>(
      base?: I,
    ): ClientResolveInfo_EvaluationContextSchemaInstance {
      return ClientResolveInfo_EvaluationContextSchemaInstance.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ClientResolveInfo_EvaluationContextSchemaInstance>, I>>(
      object: I,
    ): ClientResolveInfo_EvaluationContextSchemaInstance {
      const message = createBaseClientResolveInfo_EvaluationContextSchemaInstance();
      message.schema = (globalThis.Object.entries(object.schema ?? {}) as [string, number][]).reduce(
        (acc: { [key: string]: number }, [key, value]: [string, number]) => {
          if (value !== undefined) {
            acc[key] = globalThis.Number(value);
          }
          return acc;
        },
        {},
      );
      return message;
    },
  };

function createBaseClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry(): ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
  return { key: '', value: 0 };
}

export const ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry: MessageFns<ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry> =
  {
    encode(
      message: ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== '') {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : '',
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      };
    },

    toJSON(message: ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry): unknown {
      const obj: any = {};
      if (message.key !== '') {
        obj.key = message.key;
      }
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry>, I>>(
      base?: I,
    ): ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
      return ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry>, I>>(
      object: I,
    ): ClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry {
      const message = createBaseClientResolveInfo_EvaluationContextSchemaInstance_SchemaEntry();
      message.key = object.key ?? '';
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseFlagResolveInfo(): FlagResolveInfo {
  return { flag: '', variantResolveInfo: [] };
}

export const FlagResolveInfo: MessageFns<FlagResolveInfo> = {
  encode(message: FlagResolveInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flag !== '') {
      writer.uint32(10).string(message.flag);
    }
    for (const v of message.variantResolveInfo) {
      FlagResolveInfo_VariantResolveInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagResolveInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagResolveInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.flag = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.variantResolveInfo.push(FlagResolveInfo_VariantResolveInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagResolveInfo {
    return {
      flag: isSet(object.flag) ? globalThis.String(object.flag) : '',
      variantResolveInfo: globalThis.Array.isArray(object?.variantResolveInfo)
        ? object.variantResolveInfo.map((e: any) => FlagResolveInfo_VariantResolveInfo.fromJSON(e))
        : globalThis.Array.isArray(object?.variant_resolve_info)
        ? object.variant_resolve_info.map((e: any) => FlagResolveInfo_VariantResolveInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FlagResolveInfo): unknown {
    const obj: any = {};
    if (message.flag !== '') {
      obj.flag = message.flag;
    }
    if (message.variantResolveInfo?.length) {
      obj.variantResolveInfo = message.variantResolveInfo.map(e => FlagResolveInfo_VariantResolveInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagResolveInfo>, I>>(base?: I): FlagResolveInfo {
    return FlagResolveInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagResolveInfo>, I>>(object: I): FlagResolveInfo {
    const message = createBaseFlagResolveInfo();
    message.flag = object.flag ?? '';
    message.variantResolveInfo =
      object.variantResolveInfo?.map(e => FlagResolveInfo_VariantResolveInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFlagResolveInfo_VariantResolveInfo(): FlagResolveInfo_VariantResolveInfo {
  return { variant: '', count: 0 };
}

export const FlagResolveInfo_VariantResolveInfo: MessageFns<FlagResolveInfo_VariantResolveInfo> = {
  encode(message: FlagResolveInfo_VariantResolveInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variant !== '') {
      writer.uint32(10).string(message.variant);
    }
    if (message.count !== 0) {
      writer.uint32(24).int64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlagResolveInfo_VariantResolveInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlagResolveInfo_VariantResolveInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variant = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlagResolveInfo_VariantResolveInfo {
    return {
      variant: isSet(object.variant) ? globalThis.String(object.variant) : '',
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: FlagResolveInfo_VariantResolveInfo): unknown {
    const obj: any = {};
    if (message.variant !== '') {
      obj.variant = message.variant;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FlagResolveInfo_VariantResolveInfo>, I>>(
    base?: I,
  ): FlagResolveInfo_VariantResolveInfo {
    return FlagResolveInfo_VariantResolveInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FlagResolveInfo_VariantResolveInfo>, I>>(
    object: I,
  ): FlagResolveInfo_VariantResolveInfo {
    const message = createBaseFlagResolveInfo_VariantResolveInfo();
    message.variant = object.variant ?? '';
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseWriteOperationsRequest(): WriteOperationsRequest {
  return { storeVariantOp: [] };
}

export const WriteOperationsRequest: MessageFns<WriteOperationsRequest> = {
  encode(message: WriteOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.storeVariantOp) {
      VariantData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.storeVariantOp.push(VariantData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteOperationsRequest {
    return {
      storeVariantOp: globalThis.Array.isArray(object?.storeVariantOp)
        ? object.storeVariantOp.map((e: any) => VariantData.fromJSON(e))
        : globalThis.Array.isArray(object?.store_variant_op)
        ? object.store_variant_op.map((e: any) => VariantData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WriteOperationsRequest): unknown {
    const obj: any = {};
    if (message.storeVariantOp?.length) {
      obj.storeVariantOp = message.storeVariantOp.map(e => VariantData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteOperationsRequest>, I>>(base?: I): WriteOperationsRequest {
    return WriteOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteOperationsRequest>, I>>(object: I): WriteOperationsRequest {
    const message = createBaseWriteOperationsRequest();
    message.storeVariantOp = object.storeVariantOp?.map(e => VariantData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWriteOperationsResult(): WriteOperationsResult {
  return {};
}

export const WriteOperationsResult: MessageFns<WriteOperationsResult> = {
  encode(_: WriteOperationsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteOperationsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteOperationsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): WriteOperationsResult {
    return {};
  },

  toJSON(_: WriteOperationsResult): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteOperationsResult>, I>>(base?: I): WriteOperationsResult {
    return WriteOperationsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteOperationsResult>, I>>(_: I): WriteOperationsResult {
    const message = createBaseWriteOperationsResult();
    return message;
  },
};

function createBaseVariantReadOp(): VariantReadOp {
  return { unit: '', materialization: '', rule: '' };
}

export const VariantReadOp: MessageFns<VariantReadOp> = {
  encode(message: VariantReadOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== '') {
      writer.uint32(10).string(message.unit);
    }
    if (message.materialization !== '') {
      writer.uint32(18).string(message.materialization);
    }
    if (message.rule !== '') {
      writer.uint32(26).string(message.rule);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantReadOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantReadOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.materialization = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantReadOp {
    return {
      unit: isSet(object.unit) ? globalThis.String(object.unit) : '',
      materialization: isSet(object.materialization) ? globalThis.String(object.materialization) : '',
      rule: isSet(object.rule) ? globalThis.String(object.rule) : '',
    };
  },

  toJSON(message: VariantReadOp): unknown {
    const obj: any = {};
    if (message.unit !== '') {
      obj.unit = message.unit;
    }
    if (message.materialization !== '') {
      obj.materialization = message.materialization;
    }
    if (message.rule !== '') {
      obj.rule = message.rule;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VariantReadOp>, I>>(base?: I): VariantReadOp {
    return VariantReadOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VariantReadOp>, I>>(object: I): VariantReadOp {
    const message = createBaseVariantReadOp();
    message.unit = object.unit ?? '';
    message.materialization = object.materialization ?? '';
    message.rule = object.rule ?? '';
    return message;
  },
};

function createBaseInclusionReadOp(): InclusionReadOp {
  return { unit: '', materialization: '' };
}

export const InclusionReadOp: MessageFns<InclusionReadOp> = {
  encode(message: InclusionReadOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== '') {
      writer.uint32(10).string(message.unit);
    }
    if (message.materialization !== '') {
      writer.uint32(18).string(message.materialization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionReadOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionReadOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.materialization = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionReadOp {
    return {
      unit: isSet(object.unit) ? globalThis.String(object.unit) : '',
      materialization: isSet(object.materialization) ? globalThis.String(object.materialization) : '',
    };
  },

  toJSON(message: InclusionReadOp): unknown {
    const obj: any = {};
    if (message.unit !== '') {
      obj.unit = message.unit;
    }
    if (message.materialization !== '') {
      obj.materialization = message.materialization;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionReadOp>, I>>(base?: I): InclusionReadOp {
    return InclusionReadOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionReadOp>, I>>(object: I): InclusionReadOp {
    const message = createBaseInclusionReadOp();
    message.unit = object.unit ?? '';
    message.materialization = object.materialization ?? '';
    return message;
  },
};

function createBaseReadOp(): ReadOp {
  return { variantReadOp: undefined, inclusionReadOp: undefined };
}

export const ReadOp: MessageFns<ReadOp> = {
  encode(message: ReadOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantReadOp !== undefined) {
      VariantReadOp.encode(message.variantReadOp, writer.uint32(10).fork()).join();
    }
    if (message.inclusionReadOp !== undefined) {
      InclusionReadOp.encode(message.inclusionReadOp, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantReadOp = VariantReadOp.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inclusionReadOp = InclusionReadOp.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadOp {
    return {
      variantReadOp: isSet(object.variantReadOp)
        ? VariantReadOp.fromJSON(object.variantReadOp)
        : isSet(object.variant_read_op)
        ? VariantReadOp.fromJSON(object.variant_read_op)
        : undefined,
      inclusionReadOp: isSet(object.inclusionReadOp)
        ? InclusionReadOp.fromJSON(object.inclusionReadOp)
        : isSet(object.inclusion_read_op)
        ? InclusionReadOp.fromJSON(object.inclusion_read_op)
        : undefined,
    };
  },

  toJSON(message: ReadOp): unknown {
    const obj: any = {};
    if (message.variantReadOp !== undefined) {
      obj.variantReadOp = VariantReadOp.toJSON(message.variantReadOp);
    }
    if (message.inclusionReadOp !== undefined) {
      obj.inclusionReadOp = InclusionReadOp.toJSON(message.inclusionReadOp);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadOp>, I>>(base?: I): ReadOp {
    return ReadOp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadOp>, I>>(object: I): ReadOp {
    const message = createBaseReadOp();
    message.variantReadOp =
      object.variantReadOp !== undefined && object.variantReadOp !== null
        ? VariantReadOp.fromPartial(object.variantReadOp)
        : undefined;
    message.inclusionReadOp =
      object.inclusionReadOp !== undefined && object.inclusionReadOp !== null
        ? InclusionReadOp.fromPartial(object.inclusionReadOp)
        : undefined;
    return message;
  },
};

function createBaseReadOperationsRequest(): ReadOperationsRequest {
  return { ops: [] };
}

export const ReadOperationsRequest: MessageFns<ReadOperationsRequest> = {
  encode(message: ReadOperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ops) {
      ReadOp.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadOperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ops.push(ReadOp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadOperationsRequest {
    return { ops: globalThis.Array.isArray(object?.ops) ? object.ops.map((e: any) => ReadOp.fromJSON(e)) : [] };
  },

  toJSON(message: ReadOperationsRequest): unknown {
    const obj: any = {};
    if (message.ops?.length) {
      obj.ops = message.ops.map(e => ReadOp.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadOperationsRequest>, I>>(base?: I): ReadOperationsRequest {
    return ReadOperationsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadOperationsRequest>, I>>(object: I): ReadOperationsRequest {
    const message = createBaseReadOperationsRequest();
    message.ops = object.ops?.map(e => ReadOp.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVariantData(): VariantData {
  return { unit: '', materialization: '', rule: '', variant: '' };
}

export const VariantData: MessageFns<VariantData> = {
  encode(message: VariantData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== '') {
      writer.uint32(10).string(message.unit);
    }
    if (message.materialization !== '') {
      writer.uint32(18).string(message.materialization);
    }
    if (message.rule !== '') {
      writer.uint32(26).string(message.rule);
    }
    if (message.variant !== '') {
      writer.uint32(34).string(message.variant);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VariantData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariantData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.materialization = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.variant = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VariantData {
    return {
      unit: isSet(object.unit) ? globalThis.String(object.unit) : '',
      materialization: isSet(object.materialization) ? globalThis.String(object.materialization) : '',
      rule: isSet(object.rule) ? globalThis.String(object.rule) : '',
      variant: isSet(object.variant) ? globalThis.String(object.variant) : '',
    };
  },

  toJSON(message: VariantData): unknown {
    const obj: any = {};
    if (message.unit !== '') {
      obj.unit = message.unit;
    }
    if (message.materialization !== '') {
      obj.materialization = message.materialization;
    }
    if (message.rule !== '') {
      obj.rule = message.rule;
    }
    if (message.variant !== '') {
      obj.variant = message.variant;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VariantData>, I>>(base?: I): VariantData {
    return VariantData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VariantData>, I>>(object: I): VariantData {
    const message = createBaseVariantData();
    message.unit = object.unit ?? '';
    message.materialization = object.materialization ?? '';
    message.rule = object.rule ?? '';
    message.variant = object.variant ?? '';
    return message;
  },
};

function createBaseInclusionData(): InclusionData {
  return { unit: '', materialization: '', isIncluded: false };
}

export const InclusionData: MessageFns<InclusionData> = {
  encode(message: InclusionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unit !== '') {
      writer.uint32(10).string(message.unit);
    }
    if (message.materialization !== '') {
      writer.uint32(18).string(message.materialization);
    }
    if (message.isIncluded !== false) {
      writer.uint32(24).bool(message.isIncluded);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InclusionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInclusionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.materialization = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isIncluded = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InclusionData {
    return {
      unit: isSet(object.unit) ? globalThis.String(object.unit) : '',
      materialization: isSet(object.materialization) ? globalThis.String(object.materialization) : '',
      isIncluded: isSet(object.isIncluded)
        ? globalThis.Boolean(object.isIncluded)
        : isSet(object.is_included)
        ? globalThis.Boolean(object.is_included)
        : false,
    };
  },

  toJSON(message: InclusionData): unknown {
    const obj: any = {};
    if (message.unit !== '') {
      obj.unit = message.unit;
    }
    if (message.materialization !== '') {
      obj.materialization = message.materialization;
    }
    if (message.isIncluded !== false) {
      obj.isIncluded = message.isIncluded;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InclusionData>, I>>(base?: I): InclusionData {
    return InclusionData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InclusionData>, I>>(object: I): InclusionData {
    const message = createBaseInclusionData();
    message.unit = object.unit ?? '';
    message.materialization = object.materialization ?? '';
    message.isIncluded = object.isIncluded ?? false;
    return message;
  },
};

function createBaseReadResult(): ReadResult {
  return { variantResult: undefined, inclusionResult: undefined };
}

export const ReadResult: MessageFns<ReadResult> = {
  encode(message: ReadResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.variantResult !== undefined) {
      VariantData.encode(message.variantResult, writer.uint32(10).fork()).join();
    }
    if (message.inclusionResult !== undefined) {
      InclusionData.encode(message.inclusionResult, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.variantResult = VariantData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inclusionResult = InclusionData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadResult {
    return {
      variantResult: isSet(object.variantResult)
        ? VariantData.fromJSON(object.variantResult)
        : isSet(object.variant_result)
        ? VariantData.fromJSON(object.variant_result)
        : undefined,
      inclusionResult: isSet(object.inclusionResult)
        ? InclusionData.fromJSON(object.inclusionResult)
        : isSet(object.inclusion_result)
        ? InclusionData.fromJSON(object.inclusion_result)
        : undefined,
    };
  },

  toJSON(message: ReadResult): unknown {
    const obj: any = {};
    if (message.variantResult !== undefined) {
      obj.variantResult = VariantData.toJSON(message.variantResult);
    }
    if (message.inclusionResult !== undefined) {
      obj.inclusionResult = InclusionData.toJSON(message.inclusionResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadResult>, I>>(base?: I): ReadResult {
    return ReadResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadResult>, I>>(object: I): ReadResult {
    const message = createBaseReadResult();
    message.variantResult =
      object.variantResult !== undefined && object.variantResult !== null
        ? VariantData.fromPartial(object.variantResult)
        : undefined;
    message.inclusionResult =
      object.inclusionResult !== undefined && object.inclusionResult !== null
        ? InclusionData.fromPartial(object.inclusionResult)
        : undefined;
    return message;
  },
};

function createBaseReadOperationsResult(): ReadOperationsResult {
  return { results: [] };
}

export const ReadOperationsResult: MessageFns<ReadOperationsResult> = {
  encode(message: ReadOperationsResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      ReadResult.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadOperationsResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadOperationsResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(ReadResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadOperationsResult {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => ReadResult.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReadOperationsResult): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map(e => ReadResult.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadOperationsResult>, I>>(base?: I): ReadOperationsResult {
    return ReadOperationsResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadOperationsResult>, I>>(object: I): ReadOperationsResult {
    const message = createBaseReadOperationsResult();
    message.results = object.results?.map(e => ReadResult.fromPartial(e)) || [];
    return message;
  },
};

export interface InternalFlagLoggerService {
  /** Client writes flag assignment events and resolve logs using client secret authentication. */
  ClientWriteFlagLogs(request: WriteFlagLogsRequest): Promise<WriteFlagLogsResponse>;
  /** Stores materializations for units. Uses client secret authentication. */
  WriteMaterializedOperations(request: WriteOperationsRequest): Promise<WriteOperationsResult>;
  /** Loads materializations for units. Uses client secret authentication. */
  ReadMaterializedOperations(request: ReadOperationsRequest): Promise<ReadOperationsResult>;
}

export const InternalFlagLoggerServiceServiceName = 'confidence.flags.resolver.v1.InternalFlagLoggerService';
export class InternalFlagLoggerServiceClientImpl implements InternalFlagLoggerService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || InternalFlagLoggerServiceServiceName;
    this.rpc = rpc;
    this.ClientWriteFlagLogs = this.ClientWriteFlagLogs.bind(this);
    this.WriteMaterializedOperations = this.WriteMaterializedOperations.bind(this);
    this.ReadMaterializedOperations = this.ReadMaterializedOperations.bind(this);
  }
  ClientWriteFlagLogs(request: WriteFlagLogsRequest): Promise<WriteFlagLogsResponse> {
    const data = WriteFlagLogsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'ClientWriteFlagLogs', data);
    return promise.then(data => WriteFlagLogsResponse.decode(new BinaryReader(data)));
  }

  WriteMaterializedOperations(request: WriteOperationsRequest): Promise<WriteOperationsResult> {
    const data = WriteOperationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'WriteMaterializedOperations', data);
    return promise.then(data => WriteOperationsResult.decode(new BinaryReader(data)));
  }

  ReadMaterializedOperations(request: ReadOperationsRequest): Promise<ReadOperationsResult> {
    const data = ReadOperationsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, 'ReadMaterializedOperations', data);
    return promise.then(data => ReadOperationsResult.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === 'string') {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER');
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === 'object' && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
